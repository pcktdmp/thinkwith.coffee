---
date: '2025-08-11T10:38:48+02:00'
title: 'Agentic AI for Brownfield Software Engineering'
---

Since Lovable Launched its agent, is my opinion the turning of consistent value creation by Agentic AI.

For prototyping ideas and merging product design and software in one entity is where it shines, but what about brown field scenarios in software development? 

When people talk about agentic AI, they tend to imagine a kind of digital colleague—capable, tireless, and independent—capable of running through the backlog while the rest of the team enjoys a leisurely coffee.

But the reality in most software engineering departments, especially those working with mature, brownfield products, is far less cinematic. Brownfield systems are complex. They are the result of years, sometimes decades, of evolution. They carry scars from urgent fixes, quick workarounds, and half-forgotten migrations. Their build scripts have been touched by more hands than anyone can count. Their operational quirks are encoded in the collective memory of the team, rather than in any document.

Dropping an autonomous AI into that ecosystem and telling it to “go fix things” is not just reckless—it’s an invitation to disruption. Instead, what works is a patient, staged approach. The goal is to introduce agentic AI in a way that adds tangible value without jeopardizing stability.

# The First Step: Read-Only Involvement

The safest starting point is to let the AI look, but not touch. This means giving it the ability to navigate the codebase, trace dependencies, and surface information for the team—without any possibility of changing the system.

At this stage, the AI can answer practical questions that developers ask every day:
Where is this feature implemented? What other parts of the system does this component depend on? Who last worked on this module? What documentation or architectural decision records relate to this function?

These capabilities may seem modest, but they immediately reduce the cognitive load on the team. Less time spent searching through files means more time spent thinking about solutions.

# From Reading to Suggesting

Once the AI has proven its ability to provide useful, accurate information, it can begin making suggestions. Importantly, these suggestions are still entirely under human control.

At this point, the AI might propose a set of unit tests for a module with poor coverage, or summarize a long chain of logs from a flaky test, highlighting a probable root cause. It might draft release notes by gathering the key points from merged pull requests.

The team still reviews, edits, and approves these outputs. The AI is not making unilateral changes; it is functioning as a skilled assistant whose work is always checked before it becomes part of the product.

# Controlled Autonomy in Narrow Domains

Only after trust has been established—both in the AI’s accuracy and in the guardrails around it—should limited autonomy be considered. Even then, this autonomy must be applied to the lowest-risk areas: documentation updates, comment improvements, architectural decision record maintenance, or small adjustments to build configurations that do not touch runtime code.

Think of this stage as giving the AI a very narrow security badge: it can walk into certain rooms, tidy them up, and leave—but it cannot go anywhere near the production floor without a human escort.

# The Importance of Measurement

In brownfield environments, success is not defined by vague impressions of “feeling faster.” It is defined by measurable improvements. Before introducing AI into the workflow, the team must capture baseline metrics: the time taken to review a pull request, the mean time to resolve incidents, the number of flaky tests, and even subjective measures such as developer satisfaction.

As the AI is introduced, these numbers should be monitored closely. If they improve without introducing new problems, that is evidence the approach is working. If they stagnate or worsen, adjustments are necessary.

# The Real Benefit: Reduced Toil

The deeper truth is that, in environments with a long history, the greatest value of agentic AI is not in writing perfect code faster than a human. It is in removing friction—the repetitive, low-skill, high-interruption work that slows engineers down and drains their attention.

Every task the AI takes over in this category—trawling through logs, writing boilerplate test cases, assembling change logs—frees human engineers to focus on work that requires context, judgment, and creativity.

Brownfield systems are like old cities: they have complex street layouts, strange architectural choices, and layers of history visible in every corner. They cannot be rebuilt overnight, and they should not be. Agentic AI, when introduced carefully, becomes a skilled guide—a traffic officer keeping flows smooth, a librarian retrieving exactly the right book, a quiet assistant setting the stage for more meaningful work.

With the right boundaries, it can bring significant value without risking the stability that makes these systems reliable in the first place.

![Brownfield with Agentic AI](/images/brown-field-ai.png)